
# PLY Simple
PLY is an implementation of lex and yacc parsing tools for Python, and it was created by David M. Beazley.
Despite being very useful, some of his grammar can be either complicated or repetitive. With PLY Simple, you can easly generate PLY and then use it for your objetives writting less and more intuitive code.
Don't forget to check the documentation before using it. ðŸ˜‰

## Website

You can also check our website where it is possible to run the application without having to clone this repository. Visit https://ply-simple.herokuapp.com!

![](WebsiteExample/website.gif)

## Documentation
This is the official documentation for PLY Simple.\
Here you can find out how to properly use the sintax of this tool.\
As you will see, some of the decisions made implementing the tool assumed that someone using PLY Simple is aware of how tradicional PLY works. With this in mind, we choose to not make some things fully automatic.
If you are not familiar with any of the following topics, please check [PLY's Documentation](https://www.dabeaz.com/ply/ply.html).


### General example
```python
%%LEX
%literals : ['+','-','/','*','=','(',')']
%ignore :' \t\n'
%reserved:
IF:'if'
THEN:'then'
%states:
exclusive: 'foo1', 'foo2'
inclusive: 'bar'
%tokens:
VAR:'[a-zA-Z_][a-zA-Z0-9_]*'   (foo1)
    return t
NUMBER:'\d+(\.\d+)?'
    t.value = float(t.value)
    return t

%eof:
    more = raw_input('... ')
    if more:
        self.lexer.input(more)
        return self.lexer.token()
    return None
%error:
    f"Illegal character '{t.value[0]}', [{t.lexer.lineno}]"
    t.lexer.skip(1)

%code:
    lexer = lex.lex()

%%YACC
%start:'start'
%prec:
'+','-' : left
'*','/' : left
'UMINUS' : right

%grammar:
Stat -> "VAR '=' Exp" {ts[p[1]] = p[3]}
    | "Exp" {print(p[1])}

Exp -> "Exp '+' Exp"
    | "Exp '-' Exp" {p[0] = p[1] - p[3]}
    | "Exp '*' Exp" {p[0] = p[1] * p[3]}
    | "Exp '/' Exp" {p[0] = p[1] / p[3]}
    | "'-' Exp %prec UMINUS" {p[0] = -p[2]}
    | "'(' Exp ')'" {p[0] = p[2]}
    | "NUMBER" {p[0] = p[1]}
    | "VAR" {p[0] = getval(p[1])}
    | "Exp2" {p[0] = ''}

Exp2 -> "NUMBER '-' '-' NUMBER" 
    | "NUMBER '+' '+' NUMBER"
    | "NUMBER"
    {for i in range(3):
        print("test")
    }
    | " " {print("Hello World!")}

%error:
    print(f"Syntax error at '{p.value}', [{p.lexer.lineno}]")

%code:
    ts = {}
    def getval(n):
        if n not in ts: print(f"Undefined name '{n}'")
        return ts.get(n,0)

    y=yacc.yacc()
    y.parse("3+4*7")

```

Looking at this example, we can easly see that program is divided into 2 components (the 2 different python files the app generates):\

- ***LEX***: Lexical analyzer which converts the source program into meaningful tokens.\
- ***YACC***: Parser that generates a parse tree from the tokens generated by Lex.

Having the previous example in mind, you can easily understand with the following documentation how each part of the PLY Simple works. Those parts which are not in the previous example, have an intuitive and simple new example.\
Instead of explaining how each part of the code works, it is more intuitive to give an example for each case and leave some notes if necessary.\
***One general note for all the PLY Simple is that it should follow the order as it is below.***

### LEX

**Before declaring any component of LEX, we should first declare at the beggining of the PLY Simple code:**

```python
%%LEX
```




#### Literals

```python
%literals = "+-/*=()"
``` 

or

```python
%literals = ['+','-','/','*','=','(',')']
``` 

#### Ignore

```python
%ignore = ' \t\n'
``` 


#### Reserved

```python
%reserved
IF : 'if'
THEN : 'then'
``` 



#### States
```python
%states:
exclusive: 'foo1', 'foo2'
inclusive: 'bar'
``` 
You can have only **exclusive**  or **inclusive** states and the order is not important.

#### Tokens

***It is mandatory to declare **tokens** for the program to properly work !!!***

```python
%tokens:
VAR:'[a-zA-Z_][a-zA-Z0-9_]*'   (foo1)
    return t
NUMBER:'\d+(\.\d+)?'
    t.value = float(t.value)
    return t
``` 

As you can see, a token can have a state. In this example ***VAR*** has the state ***foo1*** the

#### Newline

```python
%new line: r'\n'
    t.lexer.lineno += 1
```

#### EOF

```python
%eof:
    more = raw_input('... ')
    if more:
        self.lexer.input(more)
        return self.lexer.token()
    return None
```

#### Error

```python
%error:
    f"Illegal character '{t.value[0]}', [{t.lexer.lineno}]"
    t.lexer.skip(1)
``` 


#### Code

***It is mandatory to declare **LEX code** for the program to properly work !!!***

```python
%code:
    lexer = lex.lex()
``` 

At least this line of code should always be written, because as we said before: "We assume that someone using PLY Simple is aware of how tradicional PLY works".

### YACC

**Before declaring any component of YACC, we should first declare after the LEX code:**

```python
%%YACC
```

#### Start

```python
%start: 'start'
```

#### Precedence

```python
%prec:
'+','-' : left
'*','/' : left
'UMINUS' : right
```

#### Grammar

***It is mandatory to declare **grammar** for the program to properly work !!! Without a grammar, the main goal of PLY is ignored...***

```python
%grammar:
Stat -> "VAR '=' Exp" {ts[p[1]] = p[3]}
    | "Exp" {print(p[1])}

Exp -> "Exp '+' Exp"
    | "Exp '-' Exp" {p[0] = p[1] - p[3]}
    | "Exp '*' Exp" {p[0] = p[1] * p[3]}
    | "Exp '/' Exp" {p[0] = p[1] / p[3]}
    | "'-' Exp %prec UMINUS" {p[0] = -p[2]}
    | "'(' Exp ')'" {p[0] = p[2]}
    | "NUMBER" {p[0] = p[1]}
    | "VAR" {p[0] = getval(p[1])}
    | "Exp2" {p[0] = ''}

Exp2 -> "NUMBER '-' '-' NUMBER" 
    | "NUMBER '+' '+' NUMBER"
    | "NUMBER"
    {for i in range(3):
        print("test")
    }
    | " " {print("Hello World!")}
```

#### Error

```python
%error:
    print(f"Syntax error at '{p.value}', [{p.lexer.lineno}]")
```



#### Code

***It is mandatory to declare **YACC code** for the program to properly work !!!***

```python
%code:
    ts = {}
    def getval(n):
        if n not in ts: print(f"Undefined name â€™{n}â€™")
        return ts.get(n,0)              

    y=yacc.yacc()
    y.parse("3+4*7")
```

At least the line ```python y=yacc.yacc()``` is mandatory. Again, someone using PLY Simple should know that this is mandatory for PLY to properly work.
